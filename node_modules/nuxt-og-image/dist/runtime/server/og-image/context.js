import { useNitroApp } from "#imports";
import { htmlPayloadCache, prerenderOptionsCache } from "#og-image-cache";
import { defu } from "defu";
import { parse } from "devalue";
import { createError, getQuery } from "h3";
import { hash } from "ohash";
import { parseURL, withoutLeadingSlash, withoutTrailingSlash, withQuery } from "ufo";
import { normalizeKey } from "unstorage";
import { separateProps, useOgImageRuntimeConfig } from "../../shared.js";
import { decodeObjectHtmlEntities } from "../util/encoding.js";
import { createNitroRouteRuleMatcher } from "../util/kit.js";
import { normaliseOptions } from "../util/options.js";
import { useChromiumRenderer, useSatoriRenderer } from "./instances.js";
export function resolvePathCacheKey(e, path) {
  const siteConfig = e.context.siteConfig.get();
  const basePath = withoutTrailingSlash(withoutLeadingSlash(normalizeKey(path || e.path)));
  return [
    !basePath || basePath === "/" ? "index" : basePath,
    hash([
      basePath,
      siteConfig.url,
      hash(getQuery(e))
    ])
  ].join(":");
}
export async function resolveContext(e) {
  const runtimeConfig = useOgImageRuntimeConfig();
  const path = parseURL(e.path).pathname;
  const extension = path.split(".").pop();
  if (!extension) {
    return createError({
      statusCode: 400,
      statusMessage: `[Nuxt OG Image] Missing OG Image type.`
    });
  }
  if (!["png", "jpeg", "jpg", "svg", "html", "json"].includes(extension)) {
    return createError({
      statusCode: 400,
      statusMessage: `[Nuxt OG Image] Unknown OG Image type ${extension}.`
    });
  }
  let queryParams = { ...getQuery(e) };
  queryParams.props = JSON.parse(queryParams.props || "{}");
  queryParams = separateProps(queryParams);
  let basePath = withoutTrailingSlash(
    path.replace(`/__og-image__/image`, "").replace(`/__og-image__/static`, "").replace(`/og.${extension}`, "")
  );
  if (queryParams._query)
    basePath = withQuery(basePath, JSON.parse(queryParams._query));
  const isDebugJsonPayload = extension === "json" && runtimeConfig.debug;
  const key = resolvePathCacheKey(e, basePath);
  let options = queryParams.options;
  if (!options) {
    if (import.meta.prerender)
      options = await prerenderOptionsCache?.getItem(key);
    if (!options) {
      const payload = await fetchPathHtmlAndExtractOptions(e, basePath, key);
      if (payload instanceof Error)
        return payload;
      options = payload;
    }
  }
  delete queryParams.options;
  const routeRuleMatcher = createNitroRouteRuleMatcher();
  const routeRules = routeRuleMatcher(basePath);
  if (typeof routeRules.ogImage === "undefined" && !options) {
    return createError({
      statusCode: 400,
      statusMessage: "The route is missing the Nuxt OG Image payload or route rules."
    });
  }
  const ogImageRouteRules = separateProps(routeRules.ogImage);
  options = defu(queryParams, options, ogImageRouteRules, runtimeConfig.defaults);
  if (!options) {
    return createError({
      statusCode: 404,
      statusMessage: "[Nuxt OG Image] OG Image not found."
    });
  }
  let renderer;
  switch (options.renderer) {
    case "satori":
      renderer = await useSatoriRenderer();
      break;
    case "chromium":
      renderer = await useChromiumRenderer();
      break;
  }
  if (!renderer || renderer.__unenv__) {
    throw createError({
      statusCode: 400,
      statusMessage: `[Nuxt OG Image] Renderer ${options.renderer} is missing.`
    });
  }
  const ctx = {
    e,
    key,
    renderer,
    isDebugJsonPayload,
    publicStoragePath: runtimeConfig.publicStoragePath,
    extension,
    basePath,
    options: normaliseOptions(options),
    _nitro: useNitroApp()
  };
  await ctx._nitro.hooks.callHook("nuxt-og-image:context", ctx);
  return ctx;
}
const PAYLOAD_REGEX = /<script.+id="nuxt-og-image-options"[^>]*>(.+?)<\/script>/;
function getPayloadFromHtml(html) {
  const match = String(html).match(PAYLOAD_REGEX);
  return match ? match[1] : null;
}
export function extractAndNormaliseOgImageOptions(html) {
  const _payload = getPayloadFromHtml(html);
  if (!_payload)
    return false;
  let options = false;
  try {
    const payload2 = parse(_payload);
    Object.entries(payload2).forEach(([key, value]) => {
      if (!value)
        delete payload2[key];
    });
    options = payload2;
  } catch (e) {
    if (import.meta.dev)
      console.warn("Failed to parse #nuxt-og-image-options", e, options);
  }
  if (!options)
    return false;
  if (typeof options.props?.description === "undefined") {
    const description = html.match(/<meta[^>]+name="description"[^>]*>/)?.[0];
    if (description) {
      const [, content] = description.match(/content="([^"]+)"/) || [];
      if (content && !options.props.description)
        options.props.description = content;
    }
  }
  const payload = decodeObjectHtmlEntities(options);
  if (import.meta.dev) {
    const socialPreview = {};
    const socialMetaTags = html.match(/<meta[^>]+(property|name)="(twitter|og):([^"]+)"[^>]*>/g);
    if (socialMetaTags) {
      socialMetaTags.forEach((tag) => {
        const [, , type, key] = tag.match(/(property|name)="(twitter|og):([^"]+)"/);
        const value = tag.match(/content="([^"]+)"/)?.[1];
        if (!value)
          return;
        if (!socialPreview[type])
          socialPreview[type] = {};
        socialPreview[type][key] = value;
      });
    }
    payload.socialPreview = socialPreview;
  }
  return payload;
}
async function fetchPathHtmlAndExtractOptions(e, path, key) {
  const cachedHtmlPayload = await htmlPayloadCache.getItem(key);
  if (!import.meta.dev && cachedHtmlPayload && cachedHtmlPayload.expiresAt < Date.now())
    return cachedHtmlPayload.value;
  let _payload = null;
  let html;
  try {
    html = await e.$fetch(path, {
      // follow redirects
      redirect: "follow",
      headers: {
        accept: "text/html"
      }
    });
    _payload = getPayloadFromHtml(html);
    if (!_payload) {
      const fallbackHtml = await globalThis.$fetch(path, {
        // follow redirects
        redirect: "follow",
        headers: {
          accept: "text/html"
        }
      });
      _payload = getPayloadFromHtml(fallbackHtml);
      if (_payload) {
        html = fallbackHtml;
      }
    }
  } catch (err) {
    return createError({
      statusCode: 500,
      statusMessage: `[Nuxt OG Image] Failed to read the path ${path} for og-image extraction. ${err.message}.`
    });
  }
  if (!_payload || !html) {
    return createError({
      statusCode: 500,
      statusMessage: `[Nuxt OG Image] Got invalid response from ${path} for og-image extraction.`
    });
  }
  const payload = extractAndNormaliseOgImageOptions(html);
  if (!import.meta.dev && payload) {
    await htmlPayloadCache.setItem(key, {
      // 60 minutes for prerender, 10 seconds for runtime
      expiresAt: Date.now() + 1e3 * (import.meta.prerender ? 60 * 60 : 10),
      value: payload
    });
  }
  return payload;
}
